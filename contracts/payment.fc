#include "common/imports.fc";
#include "payment/imports.fc";

global slice ctx_owner;
global int ctx_fee;

() load_data() impure {
    var ds = get_data().begin_parse();

    ctx_owner = ds~load_msg_addr();
    ctx_fee = ds~load_coins();

    ds.end_parse();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();

    int flags = cs~load_uint(4);

    int bounced = flags & 1;
    if (bounced) {
        return ();
    }
    slice sender = cs~load_msg_addr();

    load_data();

    (int op, int query_id) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    if (op == op::transfer_notification) {

        (int jetton_amount, slice to_address) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());

        ;; swap swapPayload
        slice ref_ds = in_msg_body~load_ref().begin_parse(); 
        
        ;; handle_swap_op
        ;; int innder_op = ref_ds~load_uint(32);
        ;; slice token_wallet1 = ref_ds~load_msg_addr();
        ;; int min_out = ref_ds~load_coins();
        ;; slice to_address = ref_ds~load_msg_addr();
        ;; int has_ref = ref_ds~load_uint(1);

        ;; force_chain(WORKCHAIN, token_wallet1, WRONG_WORKCHAIN);

        ;; builder body_ref = begin_cell()
        ;;     .store_slice(from_user);

        ;; if (has_ref) {
        ;;     slice ref_address = ref_ds~load_msg_addr();
        ;;     body_ref = body_ref.store_slice(ref_address);
        ;; body = body.store_ref(body_ref.end_cell());


        var _body = create_simple_transfer_body(query_id, 1, 1, to_address);
        _body = _body.store_uint(0, 32);                ;; append exit code
        
        send_simple_message(jetton_amount, to_address, _body.end_cell(), 64); ;; CARRY_REMAINING_GAS

        return ();
    }

    throw(0xffff);
}
 
int fee() method_id {
    load_data();
    return ctx_fee;
}

slice owner() method_id {
    load_data();
    return ctx_owner;
}

cell config() method_id {
    return get_data();
}